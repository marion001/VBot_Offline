<!DOCTYPE html>
<html lang="vi">
<!--
  #Code By: V≈© Tuy·ªÉn
  #Designed by: BootstrapMade
  #GitHub VBot: https://github.com/marion001/VBot_Offline.git
  #Facebook Group: https://www.facebook.com/groups/1148385343358824
  #Facebook: https://www.facebook.com/TWFyaW9uMDAx
  -->

<head>
    <meta charset="UTF-8">
    <title>VBot Audio Streaming WebSocket</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
	<meta name="description" content="VBot Assistant - Loa Th√¥ng Minh VBot ti·∫øng Vi·ªát, t√≠ch h·ª£p tr·ª£ l√Ω ·∫£o gi√∫p ƒëi·ªÅu khi·ªÉn nh√† th√¥ng minh, ph√°t nh·∫°c, nh·∫Øc nh·ªü v√† nhi·ªÅu ti·ªán √≠ch kh√°c. Tr·∫£i nghi·ªám loa th√¥ng minh cho ng∆∞·ªùi Vi·ªát.">
	<meta name="keywords" content="VBot Assistant, Loa Th√¥ng Minh VBot, Loa Th√¥ng Minh Ti·∫øng Vi·ªát, Loa Th√¥ng Minh Tr·ª£ L√Ω ·∫¢o VBot, tr·ª£ l√Ω ·∫£o, loa th√¥ng minh Vi·ªát Nam, ƒëi·ªÅu khi·ªÉn gi·ªçng n√≥i, nh√† th√¥ng minh">
	<meta name="author" content="V≈© Tuy·ªÉn">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        #logDisplay {
            height: 250px;
            overflow-y: auto;
            background-color: #212529;
            color: #ffffff;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
        }
        
        .error {
            color: red;
        }
        
        .success {
            color: green;
        }
        
        .info {
            color: blue;
        }
    </style>
</head>

<body class="container mt-4">

    <h2 class="text-center mb-4">VBot Audio Streaming (WebSocket)</h2>

    <div class="card shadow-sm mb-4">
        <div class="card-body">
            <h5 class="card-title">Thi·∫øt L·∫≠p K·∫øt N·ªëi</h5>
            <div class="mb-3">
                <label for="serverUrl" class="form-label">ƒê·ªãa Ch·ªâ Server Socket Streaming:</label>
                <input type="text" id="serverUrl" class="form-control border-success" value="ws://192.168.14.194:5003">
            </div>
            <button class="btn btn-success d-flex align-items-center gap-2">
                <input class="form-check-input" type="checkbox" id="enableSocket" onchange="toggleWebSocket()">
                <label class="form-check-label mb-0" for="enableSocket">K·∫øt n·ªëi T·ªõi Server</label>
            </button>
            <br/>
            <button id="startRecording" class="btn btn-primary me-2" onclick="startRecording()">üé§ B·∫≠t Microphone</button>
            <button id="stopRecording" class="btn btn-danger" disabled onclick="stopRecording()">üõë T·∫Øt Microphone</button>
        </div>
    </div>

    <div class="card shadow-sm">
        <div class="card-body">
            <h5 class="card-title">Logs D·ªØ Li·ªáu T·ª´ Server</h5> C·∫ßn ƒë√°nh th·ª©c WakeUP b·∫±ng t·ª´ n√≥ng Hotword v√†o Microphone ·ªü Ph√≠a Client.
            <div id="logDisplay" class="border"></div>
        </div>
    </div>

    <script>
        // Bi·∫øn to√†n c·ª•c ƒë·ªÉ qu·∫£n l√Ω WebSocket, recorder, stream v√† tr·∫°ng th√°i
        let socket = null; // WebSocket k·∫øt n·ªëi ƒë·∫øn server
        let recorder = null; // B·ªô x·ª≠ l√Ω ghi √¢m
        let mediaStream = null; // Lu·ªìng d·ªØ li·ªáu √¢m thanh t·ª´ microphone
        let isRecording = false; // Tr·∫°ng th√°i ghi √¢m
        let context = null; // AudioContext ƒë·ªÉ x·ª≠ l√Ω √¢m thanh
        const sampleRate = 16000; // T·∫ßn s·ªë l·∫•y m·∫´u (16kHz)
        const chunkSize = 512; // K√≠ch th∆∞·ªõc m·ªói kh·ªëi √¢m thanh g·ª≠i ƒëi
        let sessionId = null; // ID phi√™n c·ªßa client
        const logDisplay = document.getElementById("logDisplay"); // V√πng hi·ªÉn th·ªã log

        // Ghi log ra giao di·ªán v√† console
        function logMessage(message, type = 'info') {
            const logEntry = document.createElement('p');
            logEntry.textContent = '[' + new Date().toLocaleTimeString() + '] ' + message;
            logEntry.className = type;
            logEntry.style.color = "#ffffff";
            try {
                // Tr√≠ch xu·∫•t JSON t·ª´ chu·ªói log (n·∫øu c√≥)
                const jsonData = JSON.parse(message.match(/\{.*\}/)?.[0]);
                if (jsonData.vbot_client_id) {
                    logEntry.style.color = "#ff9800";
                } else if (jsonData.waiting_to_wake_up) {
                    logEntry.style.color = "#00FF00";
                } else if (jsonData.wake_word_detected) {
                    logEntry.style.color = "#00FF00";
                } else if (jsonData.recording_streaming) {
                    logEntry.style.color = "#2196F3";
                }
            } catch (e) {
                //console.log("[L·ªói JSON] Kh√¥ng th·ªÉ parse JSON h·ª£p l·ªá:", message);
                logEntry.style.color = "#ffffff";
            }
            logDisplay.appendChild(logEntry);
            logDisplay.scrollTop = logDisplay.scrollHeight;
            //console.log(message);
        }

        // L·∫•y URL c·ªßa WebSocket t·ª´ √¥ nh·∫≠p
        function getServerUrl() {
            return document.getElementById("serverUrl").value;
        }

        // K·∫øt n·ªëi WebSocket
        function connectWebSocket() {
            // Tr√°nh k·∫øt n·ªëi l·∫°i khi ƒë√£ m·ªü
            if (socket && socket.readyState === WebSocket.OPEN) return;
            // T·∫°o WebSocket ƒë·∫øn server
            socket = new WebSocket(getServerUrl());
            // S·ª± ki·ªán khi WebSocket m·ªü
            socket.onopen = function() {
                logMessage("[Client] K·∫øt n·ªëi WebSocket th√†nh c√¥ng t·ªõi: " + getServerUrl(), "success");
                // T·∫°o sessionId ng·∫´u nhi√™n ƒë·ªÉ nh·∫≠n di·ªán client
                sessionId = "client_" + Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
                socket.send(sessionId);
                logMessage("[Client] G·ª≠i Session ID: " + sessionId, "info");
            };
            // S·ª± ki·ªán nh·∫≠n tin nh·∫Øn t·ª´ server
            socket.onmessage = function(event) {
                logMessage("[Server] " + event.data, "info");
            };
            // S·ª± ki·ªán khi WebSocket ƒë√≥ng
            socket.onclose = function() {
                logMessage("WebSocket ƒë√£ ƒë√≥ng.", "error");
            };
            // X·ª≠ l√Ω l·ªói k·∫øt n·ªëi WebSocket
            socket.onerror = function(error) {
                logMessage("L·ªói WebSocket: " + error.message, "error");
                socket.close();
            };
        }

        // Ng·∫Øt k·∫øt n·ªëi WebSocket
        function disconnectWebSocket() {
            if (socket) {
                logMessage("ƒê√≥ng k·∫øt n·ªëi WebSocket...", "info");
                socket.close();
                socket = null;
            }
        }

        // B·∫≠t/t·∫Øt WebSocket khi click v√†o checkbox
        function toggleWebSocket() {
            if (document.getElementById("enableSocket").checked) {
                connectWebSocket();
                // Ki·ªÉm tra quy·ªÅn microphone sau khi k·∫øt n·ªëi WebSocket
                setTimeout(() => {
                    /*
            checkMicrophonePermission(function (granted) {
                if (!granted) {
                    logMessage("Microphone ch∆∞a ƒë∆∞·ª£c c·∫•p quy·ªÅn! H√£y ki·ªÉm tra c√†i ƒë·∫∑t tr√¨nh duy·ªát.", "error");
                }
            });
			*/
                    // ƒê·ª£i 1 gi√¢y ƒë·ªÉ ch·∫Øc ch·∫Øn WebSocket ƒë√£ k·∫øt n·ªëi
                }, 1000);
            } else {
                disconnectWebSocket();
            }
        }

        // H√†m ki·ªÉm tra quy·ªÅn truy c·∫≠p microphone
        function checkMicrophonePermission(callback) {
            if (!navigator.permissions) {
                logMessage("Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ ki·ªÉm tra quy·ªÅn, th·ª≠ truy c·∫≠p microphone...", "warning");
                callback(true);
                return;
            }
            navigator.permissions.query({
                name: "microphone"
            }).then(function(permissionStatus) {
                if (permissionStatus.state === "granted") {
                    logMessage("Quy·ªÅn microphone ƒë√£ ƒë∆∞·ª£c c·∫•p.", "success");
                    callback(true);
                    startRecording();
                } else if (permissionStatus.state === "denied") {
                    logMessage("Quy·ªÅn microphone b·ªã t·ª´ ch·ªëi! H√£y ki·ªÉm tra c√†i ƒë·∫∑t tr√¨nh duy·ªát.", "error");
                    alert("Vui l√≤ng c·∫•p quy·ªÅn microphone trong c√†i ƒë·∫∑t tr√¨nh duy·ªát ƒë·ªÉ s·ª≠ d·ª•ng t√≠nh nƒÉng n√†y.");
                    callback(false);
                } else {
                    logMessage("C·∫ßn c·∫•p quy·ªÅn truy c·∫≠p Microphone tr√™n tr√¨nh duy·ªát", "warning");
                    navigator.mediaDevices.getUserMedia({
                            audio: true
                        })
                        .then(function(stream) {
                            logMessage("Quy·ªÅn microphone ƒë√£ ƒë∆∞·ª£c c·∫•p th√†nh c√¥ng", "success");
                            // ƒê√≥ng stream sau khi y√™u c·∫ßu th√†nh c√¥ng
                            stream.getTracks().forEach(track => track.stop());
                            callback(true);
                            startRecording()
                        })
                        .catch(function(error) {
                            logMessage("Ng∆∞·ªùi d√πng t·ª´ ch·ªëi c·∫•p quy·ªÅn microphone!", "error");
                            alert("B·∫°n c·∫ßn c·∫•p quy·ªÅn microphone ƒë·ªÉ s·ª≠ d·ª•ng t√≠nh nƒÉng n√†y.");
                            callback(false);
                        });
                }
            });
        }

        // B·∫Øt ƒë·∫ßu ghi √¢m v√† g·ª≠i d·ªØ li·ªáu qua WebSocket
        function startRecording() {
            if (isRecording || !document.getElementById("enableSocket").checked) return;
            isRecording = true;
            // ƒê·∫£m b·∫£o WebSocket ƒë√£ k·∫øt n·ªëi tr∆∞·ªõc khi g·ª≠i √¢m thanh
            connectWebSocket();
            // Ki·ªÉm tra tr√¨nh duy·ªát c√≥ h·ªó tr·ª£ microphone kh√¥ng
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                navigator.mediaDevices.getUserMedia({
                        audio: true
                    })
                    .then(function(stream) {
                        logMessage("B·∫Øt ƒë·∫ßu thu √¢m Streaming...", "success");
                        // Kh·ªüi t·∫°o AudioContext v·ªõi t·∫ßn s·ªë 16kHz
                        window.AudioContext = window.AudioContext || window.webkitAudioContext;
                        context = new AudioContext({
                            sampleRate: sampleRate
                        });
                        // T·∫°o ngu·ªìn √¢m thanh t·ª´ microphone
                        mediaStream = context.createMediaStreamSource(stream);
                        // T·∫°o b·ªô x·ª≠ l√Ω ghi √¢m, x·ª≠ l√Ω t·ª´ng kh·ªëi 512 m·∫´u
                        recorder = context.createScriptProcessor(chunkSize, 1, 1);
                        // S·ª± ki·ªán khi c√≥ √¢m thanh thu ƒë∆∞·ª£c
                        recorder.onaudioprocess = function(e) {
                            if (!isRecording || !socket || socket.readyState !== WebSocket.OPEN) return;
                            const inputBuffer = e.inputBuffer;
                            // L·∫•y d·ªØ li·ªáu t·ª´ k√™nh √¢m thanh ƒë·∫ßu ti√™n
                            const inputData = inputBuffer.getChannelData(0);
                            // Chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu t·ª´ float (-1 ƒë·∫øn 1) sang Int16 (-32768 ƒë·∫øn 32767)
                            const int16Array = new Int16Array(chunkSize);
                            for (let i = 0; i < chunkSize; i++) {
                                int16Array[i] = Math.max(-32768, Math.min(32767, inputData[i] * 32768));
                            }
                            // G·ª≠i d·ªØ li·ªáu √¢m thanh ƒë·∫øn server
                            socket.send(int16Array.buffer);
                        };
                        // K·∫øt n·ªëi lu·ªìng √¢m thanh v·ªõi b·ªô x·ª≠ l√Ω
                        mediaStream.connect(recorder);
                        recorder.connect(context.destination);
                        // V√¥ hi·ªáu h√≥a n√∫t "B·∫≠t Microphone" v√† b·∫≠t "T·∫Øt Microphone"
                        document.getElementById("startRecording").disabled = true;
                        document.getElementById("stopRecording").disabled = false;
                    })
                    .catch(function(e) {
                        logMessage("L·ªói truy c·∫≠p micr√¥: " + e.message, "error");
                    });
            } else {
                logMessage("Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ getUserMedia", "error");
            }
        }

        // D·ª´ng ghi √¢m v√† ng·∫Øt k·∫øt n·ªëi microphone
        function stopRecording() {
            if (!isRecording) return;
            isRecording = false;
            // Ng·∫Øt k·∫øt n·ªëi c√°c th√†nh ph·∫ßn audio
            if (recorder) recorder.disconnect();
            if (mediaStream) mediaStream.disconnect();
            if (context) context.close();
            // K√≠ch ho·∫°t l·∫°i n√∫t "B·∫≠t Microphone"
            document.getElementById("startRecording").disabled = false;
            document.getElementById("stopRecording").disabled = true;
            logMessage("[Client] ƒê√£ Ng·∫Øt K·∫øt N·ªëi Microphone", "info");
            // G·ª≠i t√≠n hi·ªáu "stop" t·ªõi server ƒë·ªÉ th√¥ng b√°o d·ª´ng ghi √¢m
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(new TextEncoder().encode("stop"));
            }
            // X√≥a session ID
            sessionId = null;
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>